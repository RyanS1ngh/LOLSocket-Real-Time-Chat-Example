const createConnection = require('./connection.js');
const { subscribeChannel, unsubscribeChannel } = require('./channels.js');
const { publishEvent } = require('./Triggers.js');
const { triggerEvent, handleEvent } = require('./CustomEventHandling.js');
const { storeMessage, getMessageHistory } = require('./MessagePersistence.js');
const disconnectOnClose = require('./DisconnectOnClose.js');
const {handleConnectionError, automaticReconnect} = require('./WebSocketErrorHandling.js');
class LOLSocket {
    constructor(apiKey, apiSecret) {
        // Initialize the LOLSocket instance with API key and secret
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;

        this.websocket = automaticReconnect(apiKey, apiSecret, (newSocket) => {
            this.websocket = newSocket;
        });

        this.channels = [];

        // Additional initialization logic can be added here

        disconnectOnClose(this.websocket, () => {
            this.websocket = automaticReconnect(apiKey, apiSecret, (newSocket) => {
                this.websocket = newSocket;
            });
        });

        handleConnectionError(this.websocket);
    }


    channel(channel, namespace) {
        subscribeChannel(this.websocket, channel, namespace);

        this.channels[channel] = this.channels[channel] || [];
        return {
            echo: (namespace, callback) => {
                this.channels[channel].push({ namespace, callback });

                this.websocket.on('message', (data) => {
                    const message = JSON.parse(data);
                    const namespace = message.namespace;
                    storeMessage(channel, message)
                    if (this.channels[message.channel]) {
                        this.channels[message.channel].forEach((subscription) => {
                            if (subscription.namespace === namespace) {
                                subscription.callback(message.data);
                            }
                        });
                    }
                });
            },
            history: (callback) => {
                getMessageHistory(channel, callback);
            },
            error: (cb) => {
              ws.onerror = (error) => {
                cb(error);
              };
            }
        }
    }

    unbind(channel, namespace) {
        unsubscribeChannel(this.websocket, channel, namespace);
    }

    publish(channel, namespace, data) {
        publishEvent(this.websocket, channel, namespace, data);
    }

    getOnline(callback) {
        this.websocket.on('message', (data) => {
            const message = JSON.parse(data);
            if (message.event === 'online') {
                callback(message.data);
            }
        });
    }

    triggerEvent(event, data) {
        triggerEvent(this.websocket, event, data);
    }

    on(event, callback) {
        handleEvent(this.websocket, event, callback);
    }

}

// Export the LOLSocket class
module.exports = LOLSocket;